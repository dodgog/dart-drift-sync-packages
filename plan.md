## simplifications:

to begin with state-based event can just transfer not just the field but the
whole object

## architecture

drift files in shared are the core definition foundation.
the query accessors are reachable both from server and client through
serverDrift.sharedDrift

no imports between folders, everything is maintained as independent packages

# surfaces

packages
    server-pkg imports backend/shared and backend/server
        initializes the server db
    client-pkg imports backend/shared and backend/client
        initializes the client db
    backend
        has all drift definitions
        for client and for server
        also has daos
        
        has a test psql and test sqlite db setup
        talks between databases in tests
        inits the db the same way server-pkg and client-pkg
        
run
    server imports server-pkg
        tests could be mock api queries
    client imports client-pkg
        tests could be mock api queries

## v1 goal

event log can be synced across psql and sqlite

# client

@function
(int items inserted)
pushPull
(List<Events>, lastServerTimestamp, authentificatedUserPushing){
### push local events
    get Events since lastServerTimestamp
    or just get ones without a serverTimestamp
    response = server event api response
    
### incorporate events from response
    append new events from response to local events
    // mutate the objects table optionally
    set new serverTimestamp
}

# server online client api

should query the postgres just like a client queries sqlite

# server event api

@function
(List<Events>, serverTimestamp)
this type could also be json or generated by drift
receiveEvents
(List<Events>, lastServerTimestamp, authentificatedUserPushing){
### appends events into the server db log
    write to Events table

### responds with all things appended since lastServerTimestamp
    read from Events table and get lastServerTimestamp

### // later optionally mutates the user's object table
}

    
# db

@all
Events
	id text not null # uuid 
    type text not null # from enum maybe
	clientId text not null reference client->id
	serverTimeStamp text
	clientTimeStamp text not null
	content text (maybe? json to begin with, but is intended to be flattened)

@all
Users
	id text
	name text

@all
Clients
	id text
	userId text reference user->id

@server
AuthentificatedUsers
	user_id text reference user->id
	token text

@client
Config
	lastSyncTime text
	clientId # unique for device
    user_id text reference user->id
	userToken
	
