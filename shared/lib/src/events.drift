import 'aaausers.drift';

CREATE TABLE events (
    id text NOT NULL PRIMARY KEY,
    type TEXT NOT NULL,
    client_id TEXT NOT NULL REFERENCES clients(id),
    server_time_stamp TEXT, -- TODO: dialect aware date https://drift.simonbinder.eu/sql_api/types/#dialect-awareness
    client_time_stamp TEXT NOT NULL, -- time should be in iso8601
    content TEXT -- TODO: add type converter and json stuff perhaps
    -- https://drift.simonbinder.eu/type_converters/#type-converters-and-json-serialization
);

CREATE INDEX event_client_id_index ON events(client_id);

-----------------
-- server
seGetEventsSinceTimestamp:
SELECT e.*
FROM events e
WHERE e.server_time_stamp > :timestamp
ORDER BY e.server_time_stamp ASC;

seInsertEvent:
INSERT INTO events (id, type, client_id, server_time_stamp, client_time_stamp,
content)
VALUES
(:id, :type, :client_id, :server_time_stamp, :client_time_stamp, :content);

seGetLatestTimestampAffectingUser:
SELECT MAX(e.server_time_stamp)
FROM events e
JOIN clients c ON e.client_id = c.id
WHERE c.user_id = :user_id;

-----------------
-- client
clGetLocalEventsToPush:
SELECT e.*
FROM events e
WHERE e.server_time_stamp IS NULL;

clInsertLocalEvent:
INSERT INTO events (id, type, client_id, client_time_stamp, content)
VALUES
(:id, :type, :client_id, :client_time_stamp, :content);

clInsertServerEvent:
INSERT INTO events (
    id,
    type,
    client_id,
    server_time_stamp,
    client_time_stamp,
    content
)
VALUES (
    :id,
    :type,
    :client_id,
    :server_time_stamp,
    :client_time_stamp,
    :content
)
ON CONFLICT (id) DO UPDATE
SET server_time_stamp = EXCLUDED.server_time_stamp
WHERE
    events.server_time_stamp IS NULL
    AND events.type = EXCLUDED.type
    AND events.client_id = EXCLUDED.client_id
    AND events.client_time_stamp = EXCLUDED.client_time_stamp
    AND events.content = EXCLUDED.content;

